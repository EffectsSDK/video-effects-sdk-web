import { FrameFormat } from "./renderer/renderer";
import { type ColorFilterConfig } from "./effects/color-filter/colorFilterEffect";
import { BackgroundSource, LayoutMode } from "./effects/virtual-background/virtual_background_effect";
import { type LowLightConfig } from "./effects/low-light/lowLightEffect";
import { FaceCombiner } from "./effects/smart-zoom/faceCombiner";
import { EffectProcessor } from "./effects/EffectProcessor";
import { AbstractEffect } from "./effects/AbstractEffect";
import { OverlayScreen, OverlayScreenOptions } from "./components/overlay-screen/overlayScreen";
import { Watermark, WatermarkOptions } from "./components/watermark/watermark";
import { StickerOptions, Stickers } from "./components/stickers/stickers";
import { LtOptions } from "./components/lower-third/lowerThird";
import { LtLeftTextbox } from "./components/lower-third/collection/leftTextbox";
import { LtHorizontalMirror } from "./components/lower-third/collection/horizontalMirror";
import { LtSlideBold } from "./components/lower-third/collection/slideBold";
import { LtDoubleSlideRect } from "./components/lower-third/collection/doubleSlideRect";
import { LtTwoSlideRects } from "./components/lower-third/collection/twoSideRects/twoSlideRects";
import { ErrorObject, ErrorCode } from "./utils/errorBus";
import { AvailableEffects } from "./settings";
import { IRecorder } from "./entities/recorder";
import { Options as sdkOptions } from "@/Options";
import { type SharpnessConfig } from "./effects/sharpness/sharpnessEffect";
import { PresetType } from "@/utils/preset";
import { EffectsEnum } from "./effects/EffectFactory";
import { ChromaKeySettings } from "@/effects/virtual-background/virtual_background_effect";
export type { ChromaKeySettings };
export type Metrics = {
    fps: number;
    segmentationInferenceTime: number;
    fullFrameDrawTime: number;
};
type ResizeSettings = {
    width: number;
    height: number;
};
export declare class tsvb {
    #private;
    private callbackStore;
    private streamProcessor;
    private effectProcessor;
    private custom_inference;
    private onnx_inference;
    private outputFrameFormat;
    private effects;
    private _renderer?;
    private _lastErrorHandler?;
    components: any;
    recorder: IRecorder;
    sdkOptions: sdkOptions;
    customer_id: string;
    constructor(customer_id: string, inference?: any);
    private onOptionsUpdate;
    createEffectInstance(key: EffectsEnum): AbstractEffect;
    getEffectInstance(key: EffectsEnum): AbstractEffect | null;
    getSnapshot(): Promise<ImageBitmap>;
    isSupported(): boolean;
    cache(clear?: boolean): Promise<void>;
    clearModelCache(): Promise<void>;
    preload(): Promise<void>;
    config(config: any): void;
    private init;
    loadEffect(type: AvailableEffects): Promise<void>;
    getCustomerId(): string;
    useStream(stream: MediaStream, resize?: ResizeSettings): void;
    setSegmentationPreset(preset: PresetType): Promise<boolean>;
    getSegmentationPreset(): PresetType;
    setBackgroundColor(color: number): void;
    getStream(): MediaStream | null;
    toCanvas(canvas: HTMLCanvasElement): void;
    setFpsLimit(limit: number): boolean;
    getMetrics(): Metrics;
    showFps(): boolean;
    hideFps(): boolean;
    freeze(): boolean;
    unfreeze(): boolean;
    enableBeautification(): boolean;
    disableBeautification(): boolean;
    setBoundaryMode(mode: string): boolean;
    setBackgroundFitMode(mode: string): boolean;
    enableChromaKey(): boolean;
    disableChromaKey(): boolean;
    setChromaKeySettings(setting: Partial<ChromaKeySettings>): boolean;
    setBoundaryLevel(level: number): boolean;
    setBeautificationLevel(level: number): boolean;
    setBlur(power: number): boolean;
    clearBlur(): boolean;
    setBackground(url: BackgroundSource): boolean;
    clearBackground(): boolean;
    enableFrameSkipping(): boolean;
    disableFrameSkipping(): boolean;
    setLayout(mode: string): boolean;
    setLayoutMode(mode: LayoutMode): boolean;
    setCustomLayout(persent: {
        xOffset?: number;
        yOffset?: number;
        size?: number;
    }): boolean;
    setFaceArea(value: number): boolean;
    setFaceDetectorAccuracy(value: number): boolean;
    getDetectedFaces(): FaceCombiner[];
    setSmartZoomSmoothing(steps: number): boolean;
    setSmartZoomSensitivity(value: number): boolean;
    setSmartZoomPerod(value: number): boolean;
    switchDrawFaceSquare(isOn: boolean): boolean;
    switchDrawPreFaceSquare(isOn: boolean): boolean;
    enableSmartZoom(): boolean;
    disableSmartZoom(): boolean;
    enableColorCorrector(): boolean;
    disableColorCorrector(): boolean;
    enableMirroring(): boolean;
    disableMirroring(): boolean;
    enableColorFilter(): boolean;
    disableColorFilter(): boolean;
    setColorFilterConfig(config: Partial<ColorFilterConfig>): boolean;
    setFilterPart(value: number): boolean;
    setColorCorrectorPeriod(value: number): boolean;
    setColorCorrectorPower(value: number): boolean;
    enableLowLightEffect(): boolean;
    disableLowLightEffect(): boolean;
    setLowLightEffectConfig(config: Partial<LowLightConfig>): boolean;
    setLowLightEffectPower(value: number): boolean;
    enableSharpnessEffect(): boolean;
    disableSharpnessEffect(): boolean;
    setSharpnessEffectConfig(config: Partial<SharpnessConfig>): boolean;
    clear(): boolean;
    run(): boolean;
    stop(): boolean;
    enablePipelineSkipping(): void;
    disablePipelineSkipping(): void;
    getEffectProcessor(): EffectProcessor;
    createComponent<K extends Keys>(arg: K extends OptionsKeys ? ComponentArguments<K> : Omit<ComponentArguments<K>, "options">): ClassType<K>;
    addComponent<K extends Keys>(c: ClassType<K>, id: string): void;
    getComponentConstructor<K extends Keys>(key: K): {
        overlay_screen: typeof OverlayScreen;
        watermark: typeof Watermark;
        lowerthird_1: typeof LtLeftTextbox;
        lowerthird_2: typeof LtHorizontalMirror;
        lowerthird_3: typeof LtSlideBold;
        lowerthird_4: typeof LtDoubleSlideRect;
        lowerthird_5: typeof LtTwoSlideRects;
        stickers: typeof Stickers;
    }[K];
    setOutputResolution(size: ResizeSettings): void;
    clearOutputResolution(): void;
    setCustomResolution(size: ResizeSettings): void;
    clearCustomResolution(): void;
    setOutputFrameFormat(format: FrameFormat): void;
    set onReady(f: Function);
    onError(handler: (e: ErrorObject) => void): void;
    getLatestErrors(): ErrorObject[];
    emulateError(code: ErrorCode): void;
    set onFrame(f: Function | undefined);
    onChangeInputResolution(f?: () => void): void;
    onAuthRequest(f?: (url: string, payload: Object) => Promise<string>): void;
    onColorFilterSuccess(f?: (id: string) => void): void;
    onLowLightSuccess(f?: () => void): void;
    onBackgroundSuccess(f?: () => void): void;
}
declare const componentsMap: {
    overlay_screen: typeof OverlayScreen;
    watermark: typeof Watermark;
    lowerthird_1: typeof LtLeftTextbox;
    lowerthird_2: typeof LtHorizontalMirror;
    lowerthird_3: typeof LtSlideBold;
    lowerthird_4: typeof LtDoubleSlideRect;
    lowerthird_5: typeof LtTwoSlideRects;
    stickers: typeof Stickers;
};
interface OptionsMap {
    overlay_screen: OverlayScreenOptions;
    watermark: WatermarkOptions;
    lowerthird_1: LtOptions;
    lowerthird_2: LtOptions;
    lowerthird_3: LtOptions;
    lowerthird_4: LtOptions;
    lowerthird_5: LtOptions;
    stickers: StickerOptions;
}
type ComponentsMap = typeof componentsMap;
type Keys = keyof ComponentsMap;
type OptionsKeys = keyof OptionsMap;
type Tuples<T> = T extends Keys ? [T, InstanceType<ComponentsMap[T]>] : never;
type SingleKey<K> = [K] extends (K extends Keys ? [K] : never) ? K : never;
type ClassType<A extends Keys> = Extract<Tuples<Keys>, [A, any]>[1];
interface ComponentArguments<K extends Keys> {
    component: SingleKey<K>;
    options?: K extends OptionsKeys ? Partial<OptionsMap[K]> : never;
}
